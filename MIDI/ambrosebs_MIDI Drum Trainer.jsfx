desc: MIDI Drum Trainer
author: Ambrose Bonnaire-Sergeant
version: 1.0
changelog:
  * Right click to toggle "Click" for all lanes
    * If any active lane is disabled, enables all lanes, otherwise disables all lanes.
  * Add buttons to move lane up/down.
  * Reserve 30 sliders per lane.
  * Increase width of Click: ON/OFF button to prevent resizing.
  * Added "{/,x}2 pattern" buttons for {halving,doubling} the current beats and divisions of lanes
  * TODO Added support for min/max velocity
  * Added support for 8 lanes
about:
  # MIDI Drum Trainer

  Based on MIDI Rhythm Trainer by Eran Talmor.


  A tool for improving your sense of rhythm.

  Key features:

  * Define a rhythmic pattern, and play along to hit the pattern. Only accurate notes will be heard!
  * Get visual and audio feedback on your performance:
      * Controllable target accuracy ("error bound")
      * Only accurate notes are  heard
      * Colors for early/late notes
      * "Probability Density" curves shows where you are usually hitting over time. 
  * Error bound: control the level of accuracy you wish to achieve.
  * Auto error bound shrink: let the tool challenge you as you improve.
  * Support complex polyrhythms, e.g: 4 beat pattern, divided to 5 in the right hand, 7 in the left hand.
  * Set up complex splits - up to 4 "lanes",  receiving separate key ranges and input channels.
  * Set "click" sounds for each lane (like a metronome).
  * "Swing" and "Phase" parameters.
  * See your progress on a "10 minute training graph"




/*******************************************************************************
*  Copyright 2025, Ambrose Bonnaire-Sergeant                                   *
*  Copyright 2023, Eran Talmor                                                 *
*  This program is free software: you can redistribute it and/or modify        *
*  it under the terms of the GNU General Public License as published by        *
*  the Free Software Foundation, either version 3 of the License, or           *
*  (at your option) any later version.                                         *
*                                                                              *
*  This program is distributed in the hope that it will be useful,             *
*  but WITHOUT ANY WARRANTY; without even the implied warranty of              *
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                *
*  GNU General Public License (http://www.gnu.org/licenses/)for more details.  *
*******************************************************************************/

slider1:4<1,32,1>Beats
slider2:0<0,7,1{1,2,3,4,5,6,7,8}>Lanes
// update error_bound_scale to have the same range as slider 3
slider3:100<1,250,1>Error Bound (ms)
slider4:0<0,1,1{Off,On}>Auto Shrink Error Bound
slider5:0<-200,200>Latency Compensation (ms)

// Hidden sliders per lane
slider16:8<1,32,1>-Divisions1
slider17:0<-0.91666, 0.91666,0.01>-Swing1
slider18:0<0,1,0.01>-Phase1
slider19:0<0,1,1>-Click1
slider20:60<0,127,1>-ClickNote1
slider21:1<1,16,1>-ClickChannel1
slider22:60<0,127,1>-ClickVel1
slider23:-1<-2147483648,2147483647,1>-Mask1
slider24:0<1,16,1>-InputChannel1
slider25:0<0,127,1>-InputMinNote1
slider26:127<0,127,1>-InputMaxNote1
slider27:0<0,127,1>-InputMinVelocity1
slider28:127<0,127,1>-InputMaxVelocity1
slider29:0<0,16,1>-CCInputChannel1
slider30:-1<-1,127,1>-CCController1
slider31:-1<-1,127,1>-CCValue1

slider46:8<1,32,1>-Divisions2
slider47:0<-0.91666, 0.91666,0.01>-Swing2
slider48:0<0,1,0.01>-Phase2
slider49:0<0,1,1>-Click2
slider50:62<0,127,1>-ClickNote2
slider51:1<1,16,1>-ClickChannel2
slider52:60<0,127,1>-ClickVel2
slider53:-1<-2147483648,2147483647,1>-Mask2
slider54:0<0,16,1>-InputChannel2
slider55:0<0,127,1>-InputMinNote2
slider56:127<0,127,1>-InputMaxNote2
slider57:0<0,127,1>-InputMinVelocity2
slider58:127<0,127,1>-InputMaxVelocity2
slider59:0<0,16,1>-CCInputChannel2
slider60:-1<-1,127,1>-CCController2
slider61:-1<-1,127,1>-CCValue2

slider76:8<1,32,1>-Divisions3
slider77:0<-0.91666, 0.91666,0.01>-Swing3
slider78:0<0,1,0.01>-Phase3
slider79:0<0,1,1>-Click3
slider80:64<0,127,1>-ClickNote3
slider81:1<1,16,1>-ClickChannel3
slider82:60<0,127,1>-ClickVel3
slider83:-1<-2147483648,2147483647,1>-Mask3
slider84:0<0,16,1>-InputChannel3
slider85:0<0,127,1>-InputMinNote3
slider86:127<0,127,1>-InputMaxNote3
slider87:0<0,127,1>-InputMinVelocity3
slider88:127<0,127,1>-InputMaxVelocity3
slider89:0<0,16,1>-CCInputChannel3
slider90:-1<-1,127,1>-CCController3
slider91:-1<-1,127,1>-CCValue3

slider106:8<1,32,1>-Divisions4
slider107:0<-0.91666, 0.91666,0.01>-Swing4
slider108:0<0,1,0.01>-Phase4
slider109:0<0,1,1>-Click4
slider110:65<0,127,1>-ClickNote4
slider111:1<1,16,1>-ClickChannel4
slider112:60<0,127,1>-ClickVel4
slider113:-1<-2147483648,2147483647,1>-Mask4
slider114:0<0,16,1>-InputChannel4
slider115:0<0,127,1>-InputMinNote4
slider116:127<0,127,1>-InputMaxNote4
slider117:0<0,127,1>-InputMinVelocity4
slider118:127<0,127,1>-InputMaxVelocity4
slider119:0<0,16,1>-CCInputChannel4
slider120:-1<-1,127,1>-CCController4
slider121:-1<-1,127,1>-CCValue4

slider136:8<1,32,1>-Divisions5
slider137:0<-0.91666, 0.91666,0.01>-Swing5
slider138:0<0,1,0.01>-Phase5
slider139:0<0,1,1>-Click5
slider140:65<0,127,1>-ClickNote5
slider141:1<1,16,1>-ClickChannel5
slider142:60<0,127,1>-ClickVel5
slider143:-1<-2147483648,2147483647,1>-Mask5
slider144:0<0,16,1>-InputChannel5
slider145:0<0,127,1>-InputMinNote5
slider146:127<0,127,1>-InputMaxNote5
slider147:0<0,127,1>-InputMinVelocity5
slider148:127<0,127,1>-InputMaxVelocity5
slider150:0<0,16,1>-CCInputChannel5
slider151:-1<-1,127,1>-CCController5
slider152:-1<-1,127,1>-CCValue5

slider166:8<1,32,1>-Divisions6
slider167:0<-0.91666, 0.91666,0.01>-Swing6
slider168:0<0,1,0.01>-Phase6
slider169:0<0,1,1>-Click6
slider170:65<0,127,1>-ClickNote6
slider171:1<1,16,1>-ClickChannel6
slider172:60<0,127,1>-ClickVel6
slider173:-1<-2147483648,2147483647,1>-Mask6
slider174:0<0,16,1>-InputChannel6
slider175:0<0,127,1>-InputMinNote6
slider176:127<0,127,1>-InputMaxNote6
slider177:0<0,127,1>-InputMinVelocity6
slider178:127<0,127,1>-InputMaxVelocity6
slider179:0<0,16,1>-CCInputChannel6
slider180:-1<-1,127,1>-CCController5
slider181:-1<-1,127,1>-CCValue6

slider196:8<1,32,1>-Divisions7
slider197:0<-0.91666, 0.91666,0.01>-Swing7
slider198:0<0,1,0.01>-Phase7
slider199:0<0,1,1>-Click7
slider200:65<0,127,1>-ClickNote7
slider201:1<1,16,1>-ClickChannel7
slider202:60<0,127,1>-ClickVel7
slider203:-1<-2147483648,2147483647,1>-Mask7
slider204:0<0,16,1>-InputChannel7
slider205:0<0,127,1>-InputMinNote7
slider206:127<0,127,1>-InputMaxNote7
slider207:0<0,127,1>-InputMinVelocity7
slider208:127<0,127,1>-InputMaxVelocity7
slider209:0<0,16,1>-CCInputChannel7
slider210:-1<-1,127,1>-CCController7
slider210:-1<-1,127,1>-CCValue7

slider226:8<1,32,1>-Divisions8
slider227:0<-0.91666, 0.91666,0.01>-Swing8
slider228:0<0,1,0.01>-Phase8
slider229:0<0,1,1>-Click8
slider230:65<0,127,1>-ClickNote8
slider231:1<1,16,1>-ClickChannel8
slider232:60<0,127,1>-ClickVel8
slider233:-1<-2147483648,2147483647,1>-Mask8
slider234:0<0,16,1>-InputChannel8
slider235:0<0,127,1>-InputMinNote8
slider236:127<0,127,1>-InputMaxNote8
slider237:0<0,127,1>-InputMinVelocity8
slider238:127<0,127,1>-InputMaxVelocity8
slider239:0<0,16,1>-CCInputChannel8
slider240:-1<-1,127,1>-CCController8
slider240:-1<-1,127,1>-CCValue8

@init
note_on = $x90;
control_change = $xB0;

error_bound_scale = 250;

sliders_per_lane = 30;
first_lane_slider = 16;
slider_offset_divs = 0;
slider_offset_swing = 1;
slider_offset_phase = 2;
slider_offset_click = 3;
slider_offset_click_note = 4;
slider_offset_click_channel = 5;
slider_offset_click_vel = 6;
slider_offset_mask = 7;
slider_offset_in_channel = 8;
slider_offset_in_min_note = 9;
slider_offset_in_max_note = 10;
slider_offset_in_min_velocity = 11;
slider_offset_in_max_velocity = 12;
slider_offset_cc_channel = 13;
slider_offset_cc_controller = 14;
slider_offset_cc_value = 15;
// Update sliders_used_per_lane when adding more sliders per lane
sliders_used_per_lane = 16;

control_phase = 1;
control_swing = 2;
control_button_div_up = 3;
control_button_div_down = 4;
control_button_click = 5;
control_button_click_vel_up = 6;
control_button_click_vel_down = 7;
control_button_click_note = 8;
control_button_click_channel_down = 9;
control_button_click_channel_up = 10;
control_button_in_channel_up = 11;
control_button_in_channel_down = 12;
control_button_in_min_note = 13;
control_button_in_max_note = 14;
control_button_in_min_velocity = 15;
control_button_in_max_velocity = 16;
control_button_training_clear = 17;
control_button_halve_pattern = 18;
control_button_double_pattern = 19;
control_button_move_lane_up = 20;
control_button_move_lane_down = 21;
control_button_delete_lane = 22;
control_button_cc_channel_up = 23;
control_button_cc_channel_down = 24;
control_button_cc_controller = 25;
// allowed up to 999 of these control_* variables until we need to update controlId().

hist_idx = 0;
max_hist = 200;
max_age = 60;
max_graph = 10*60;
hit_memory = 0.97;
prev_select = -1;
histogram_buckets = 1024;
histogram_size = histogram_buckets*2;
hist_idx = 0;

heap_top = 0;

function malloc(size) local(p) (
  p = heap_top;
  heap_top += size;
  p;
);

v_history_time = malloc(max_hist); 
v_history_rel_time = malloc(max_hist);
v_history_hits = malloc(max_hist);
v_history_lane = malloc(max_hist);
v_history_notes = malloc(max_hist);
memset(v_history_time, 0, max_hist);
memset(v_history_rel_time, 0, max_hist);
memset(v_history_hits, 0, max_hist);
memset(v_history_lane, 0, max_hist);
memset(v_history_notes, 0, max_hist);
v_midi_monitor_last_hit = malloc(4);
v_play_indices = malloc(4);
v_play_timers = malloc(4);
v_play_off_timers = malloc(4);
v_graph_hit_rate = malloc(max_graph);
v_graph_error_bound = malloc(max_graph);
v_histogram = malloc(4*histogram_size);
v_histogram_tmp = malloc(histogram_size);
v_histogram_max_value = malloc(4);
v_rounds = malloc(4);
v_beat_pos = malloc(4);

v_normal_dist = malloc(31);
v_normal_dist[0] = 0;
v_normal_dist[1] = 0.0398;
v_normal_dist[2] = 0.0793;
v_normal_dist[3] = 0.1179;
v_normal_dist[4] = 0.1554;
v_normal_dist[5] = 0.1915;
v_normal_dist[6] = 0.2257;
v_normal_dist[7] = 0.258;
v_normal_dist[8] = 0.2881;
v_normal_dist[9] = 0.3159;
v_normal_dist[10] = 0.3413;
v_normal_dist[11] = 0.3643;
v_normal_dist[12] = 0.3849;
v_normal_dist[13] = 0.4032;
v_normal_dist[14] = 0.4192;
v_normal_dist[15] = 0.4332;
v_normal_dist[16] = 0.4452;
v_normal_dist[17] = 0.4554;
v_normal_dist[18] = 0.4641;
v_normal_dist[19] = 0.4713;
v_normal_dist[20] = 0.4772;
v_normal_dist[21] = 0.4821;
v_normal_dist[22] = 0.4861;
v_normal_dist[23] = 0.4893;
v_normal_dist[24] = 0.4918;
v_normal_dist[25] = 0.4938;
v_normal_dist[26] = 0.4953;
v_normal_dist[27] = 0.4965;
v_normal_dist[28] = 0.4974;
v_normal_dist[29] = 0.4981;
v_normal_dist[30] = 0.4987;

v_normal_mask = malloc(histogram_size);

function modOne(x)
(
  x - floor(x);
);

function normal_dist(x)
(
  abs_idx = min(30, floor(abs(x)*10));
  next_idx = min(30, abs_idx+1);
  dx = abs(x)*10 - abs_idx;
  p1 = (x >= 0 ? v_normal_dist[abs_idx] : -v_normal_dist[abs_idx]);
  p2 = (x >- 0 ? v_normal_dist[next_idx] : -v_normal_dist[next_idx]);
  p1*(1-dx) + p2*dx;
);

function normal_slice(x, w)
(
  normal_dist(x+w/2) - normal_dist(x-w/2);
);

function setNormalMask(h) local(i, y)
(
  memset(v_normal_mask, 0, histogram_size);
  
  i = 0;
  while (i<histogram_buckets/2) (
    y = normal_slice(h*(i/histogram_buckets),0.1)/5;
    v_normal_mask[i*2] = y;
    v_normal_mask[histogram_size-i*2-2] = y;
    i += 1;
  );
  fft(v_normal_mask, histogram_buckets);
);

function resetPlay() local(i)
(
  memset(v_play_timers, -1, 4);
  memset(v_play_indices, -1, 4);
);

resetPlay();

function isPlaying()
(
  // playing or recording
  play_state == 1 || play_state == 5;
);

function getBeats()
(
  slider1;
);

// Relative time to the beats
function getRelTime(sample_offset) local(p)
(
  p = (beat_position + (sample_offset * (tempo / 60) / srate))/getBeats();
  p - floor(p);
);

function setLanes(nlanes)
(
  nlanes >= 1 && nlanes <= lanes_limit ? (slider2 = nlanes);
  slider_automate(2 ^ 2);
);

// Getters and Setters
function getSliderIdx(lane, slider_offset)
(
   first_lane_slider + sliders_per_lane*lane + slider_offset;
);

function getSlider(lane, slider_offset) local(idx)
( 
  slider(getSliderIdx(lane, slider_offset))
);

function setSlider(lane, slider_offset, value, min_val, max_val, reset_play) local(idx)
( 
  idx = getSliderIdx(lane, slider_offset);
  slider(idx) = min(max_val, max(min_val, value));
  slider_automate(2 ^ idx);
  reset_play ? resetPlay();
);


function getDivs(lane)
( 
  getSlider(lane, slider_offset_divs);
);

function updateMaxDivs() local(i)
(
  max_divs = 0;
  i=0;
  while (i<num_lanes) (
    max_divs = max(max_divs, getDivs(i));
    i += 1;
  );
  setNormalMask(max_divs*20);
);

function setDivs(lane, value)
(
  value = floor(value);
  setSlider(lane, slider_offset_divs, value, 1, 32, 1);
  updateMaxDivs();
);

function getSwing(lane)
(
  getSlider(lane, slider_offset_swing);
);

function setSwing(lane, value) local(idx)
(
  setSlider(lane, slider_offset_swing, value, -0.91666, 0.91666, 1);
);

function getPhase(lane)
(
  getSlider(lane, slider_offset_phase);
);

function setPhase(lane, value) local(idx)
(
  setSlider(lane, slider_offset_phase, value, -1, 1, 1);
);

function getClick(lane)
(
  getSlider(lane, slider_offset_click);
);

function setClick(lane, value) local(idx)
(
  setSlider(lane, slider_offset_click, value, 0, 1, 1);
);

function getClickNote(lane)
(
  getSlider(lane, slider_offset_click_note);
);

function setClickNote(lane, value) local(idx)
(
  setSlider(lane, slider_offset_click_note, value, 0, 127, 0);
);

function getClickVel(lane)
(
  getSlider(lane, slider_offset_click_vel);
);

function setClickVel(lane, value) local(idx)
(
  setSlider(lane, slider_offset_click_vel, value, 0, 127, 0);
);

function getClickChannel(lane)
(
  getSlider(lane, slider_offset_click_channel);
);

function setClickChannel(lane, value) local(idx)
(
  setSlider(lane, slider_offset_click_channel, value, 1, 16, 1);
);

// if any active lane has click disabled:
// - enable click on all lanes;
// - otherwise disable on all lanes.
function toggleClickAllLanes() local(i, new_click_state)
(
  new_click_state = 0;
  i = 0;
  while(i < num_lanes && !new_click_state) (
    getClick(i) == 0 ? new_click_state = 1;
    i += 1;
  );
  
  i = 0;
  while(i < lanes_limit) (
    setClick(i, new_click_state);
    i += 1;
  );
);

function getMask(lane)
(
  getSlider(lane, slider_offset_mask);
);

function setMask(lane, value)
(
  setSlider(lane, slider_offset_mask, value, -2147483648, 2147483647, 0);
);

function bitSet(mask, bit, onOrOff)
(
  onOrOff ?
    (mask | (1<<bit))
  : (mask & (-1 ~ (1<<bit)));
);

function isGridEnabled(lane, idx) local(d,idx,mask)
(
  d = getDivs(lane);
  idx = (idx + d) % d;
  mask = getMask(lane);
  mask & (1<<idx);
);

function getGridMask(lane, idx) local(d)
(
  d = getDivs(lane);
  idx = (idx + d) % d;
  1 & (getMask(lane) >> idx);
);

function setGridMask(lane, idx, value) local(d)
(
  d = getDivs(lane);
  idx = (idx + d) % d;
  value ?
    setMask(lane, getMask(lane) | (1<<idx))
  : setMask(lane, getMask(lane) & (-1 ~ 1<<idx));
);

function getInputChannel(lane)
(
  getSlider(lane, slider_offset_in_channel);
);

function setInputChannel(lane, value)
(
  setSlider(lane, slider_offset_in_channel, value, 0, 16, 0);
);

function getCCChannel(lane)
(
  getSlider(lane, slider_offset_cc_channel);
);

function setCCChannel(lane, value)
(
  setSlider(lane, slider_offset_cc_channel, value, 0, 16, 0);
);

// Returns -1 if this lane is not listening for MIDI CC events.
function getCCController(lane)
(
  getSlider(lane, slider_offset_cc_controller);
);

function setCCController(lane, value)
(
  setSlider(lane, slider_offset_cc_controller, value, -1, 127, -1);
);

// Returns the latest known value for the lane's controller.
// If getCCController(lane) is -1, returns garbage as the lane is not listening to any controller.
function getCCValue(lane)
(
  getSlider(lane, slider_offset_cc_value);
);

function setCCValue(lane, value)
(
  setSlider(lane, slider_offset_cc_value, value, -1, 127, -1);
);

function getInputMinNote(lane)
(
  getSlider(lane, slider_offset_in_min_note);
);

function setInputMinNote(lane, value)
(
  setSlider(lane, slider_offset_in_min_note, value, 0, 127, 0);
);

function getInputMaxNote(lane)
(
  getSlider(lane, slider_offset_in_max_note);
);

function setInputMaxNote(lane, value)
(
  setSlider(lane, slider_offset_in_max_note, value, 0, 127, 0);
);

function getInputMinVelocity(lane)
(
  getSlider(lane, slider_offset_in_min_velocity);
);

function setInputMinVelocity(lane, value)
(
  setSlider(lane, slider_offset_in_min_velocity, value, 0, 127, 0);
);

function getInputMaxVelocity(lane)
(
  getSlider(lane, slider_offset_in_max_velocity);
);

function setInputMaxVelocity(lane, value)
(
  setSlider(lane, slider_offset_in_max_velocity, value, 0, 127, 0);
);

// Check if a lane is active (within bounds of visible lanes)
function activeLane(lane)
(
  lane >= 0 && lane < num_lanes;
);

// Swap two slider values and automate both
function swapSliders(idx1, idx2) local(tmp)
(
  tmp = slider(idx1);
  slider(idx1) = slider(idx2);
  slider(idx2) = tmp;
  slider_automate(2 ^ idx1);
  slider_automate(2 ^ idx2);
);

// Move a lane from oldLane to newLane, shifting other lanes to fill holes
// and preserving the order of shifted lanes.
// Algorithm: if moving down (to higher index), swap with next lane repeatedly until reaching target.
// If moving up (to lower index), swap with previous lane repeatedly until reaching target.
function moveLane(oldLane, newLane) local(direction, currentLane, laneSlider, oldIdx, newIdx)
(
  (oldLane != newLane && activeLane(oldLane) && activeLane(newLane)) ? (
    direction = (newLane > oldLane) ? 1 : -1;
    currentLane = oldLane;

    // Iteratively swap the lane with adjacent lane (in direction of newLane) until reaching newLane
    while (currentLane != newLane) (
      laneSlider = 0;
      while (laneSlider < sliders_used_per_lane) (
        oldIdx = getSliderIdx(currentLane, laneSlider);
        newIdx = getSliderIdx(currentLane + direction, laneSlider);
        swapSliders(oldIdx, newIdx);
        laneSlider += 1;
      );
      currentLane += direction;
    );

    // Reset play after moving lanes
    resetPlay();
  );
);

// move lane to the end of the active lanes and decrement the number of lanes.
// TODO reset "deleted" lane to stock settings
function deleteLane(lane)
(
  num_lanes > 1 && activeLane(lane) ?
    (moveLane(lane, num_lanes-1);
     setLanes(num_lanes-1);
     resetPlay(););
);

//
function getGridRaw(lane, divs, i)
(
  (i + (i&1 ? getSwing(lane) : 0) + getPhase(lane))/divs;
);

function getGrid(lane, divs, i) local(r)
(
  r = getGridRaw(lane, divs, (i+divs)%divs);
  (i<0) ? r-1 : (i>=divs) ? r+floor(i/divs) : r;
);

// Return ratio of green window per division. 1.0 == entire pattern.
function getErrorRange()
(
  error_bound * error_bound_scale * tempo / 60000 / getBeats();
);

function getEarly(lane, divs, i)
(
  getGrid(lane, divs, i) - getErrorRange();
);

function getLate(lane, divs, i)
(
  getGrid(lane, divs, i) + getErrorRange();
);

function getMidiMonitorAge(lane)
(
  time_precise() - v_midi_monitor_last_hit[lane];
);

function adjustErrorBound(hit_rate) local(level)
(
  (hit_rate > 0.9) ? 
    (level = (error_bound < 0.2 ? 0.001 : error_bound <= 0.3 ? 0.002 : error_bound <= 0.4 ?  0.005 : 0.01);
    (error_bound = max(0, error_bound - level)));
  slider3 = error_bound*error_bound_scale;
);

// returns: 0 == hit, -1 == early, 1 == late
function isHit(reltime, lane) local(i, hit, min_late, min_early, delta_early, delta_late, divs)
(
  i=0;
  hit = 0;
  min_late = 1;
  min_early = 1;
  divs = getDivs(lane);
  while(
    delta_early = max(0, getEarly(lane, divs, i)) - reltime;
    delta_late = reltime - min(1, getLate(lane, divs, i));
    hit |= isGridEnabled(lane, i) && (delta_early <= 0) && (delta_late <= 0);
    delta_early > 0 ? (min_early = min(min_early, delta_early));
    delta_late > 0 ? (min_late = min(min_late, delta_late));
    i += 1;
    !hit && (i <= divs)
  );
  hit ? 0 : (min_late > min_early ? -1 : 1); 
);

function controlId(lane, control)
(
  (lane + 1)*1000 + control;
);

// halve beats and divisions of all lanes, if divisible.
// essentially truncates the current pattern to be just the first half.
// TODO double mask
function halveDuration() local(lane, ok, newBeats, newDivs)
(
  // check that doubling durations stays within bounds before doubling
  newBeats = getBeats()/2;
  (newBeats >= 1 &&
   newBeats == floor(newBeats) &&
    (ok = 1;
     lane = 0;
     while(ok && lane < lanes_limit)
     (
       newDivs = getDivs(lane)/2;
       newDivs < 1 || newDivs != floor(newDivs) ? ok = 0;
       lane += 1; 
     );
     ok;
    );
  ) ?
  (slider(1) = newBeats;
   lane = 0;
   while(lane < lanes_limit)
   (
     setDivs(lane, getDivs(lane)/2);
     lane += 1; 
   )
  );
);

// double beats and divisions of all lanes.
// essentially extends the current pattern to be twice as long.
function doubleDuration() local(lane, ok, newBeats, oldDivs, oldMask, newMask, i)
(
  // check that doubling durations stays within bounds before doubling
  newBeats = getBeats()*2;
  (newBeats <= beats_limit &&
    (ok = 1;
     lane = 0;
     while(ok && lane < lanes_limit)
     (
       getDivs(lane)*2 > divs_limit ? ok = 0;
       lane += 1; 
     );
     ok;
    );
  ) ?
  (slider(1) = newBeats;
   lane = 0;
   while(lane < lanes_limit)
   (
     oldDivs = getDivs(lane);
     oldMask = getMask(lane);
     // Copy first half of mask to second half
     newMask = oldMask;
     i = 0;
     while(i < oldDivs)
     (
       newMask = bitSet(newMask, i+oldDivs, oldMask & (1<<i));
       i += 1;
     );
     setDivs(lane, oldDivs*2);
     setMask(lane, newMask);
     lane += 1; 
   )
  );
);

// compensation converted to number of samples
function getRelLatencyCompensation()
(
  tempo*slider5/(1000*60*getBeats());
);

@slider

num_lanes = slider2+1;
lanes_limit = 8; // manually set in slider2
beats_limit = 32; // manually set in slider1
divs_limit = 32; // manually set in slider13, slider26, ...
error_bound = slider3/error_bound_scale;
auto_shrink = slider4;
updateMaxDivs();
resetPlay();

@block

function playGrid(lane) local(sp_per_beat, sp_now, divs, sp_grid, channel, i, prev_beat_position)
(
  beat_position < prev_beat_position ? resetPlay();

  channel = getClickChannel(lane)-1;
  (v_play_off_timers[lane] < samplesblock) ? (
    midisend(max(0, v_play_off_timers[lane]), $x90 + channel, getClickNote(lane), 0);
    v_play_off_timers[lane] = 1000000;
  );   

  sp_per_beat = srate * 60 / tempo;
  sp_now = floor(0.001 + beat_position * sp_per_beat);
  divs = getDivs(lane);  

  while (v_play_timers[lane] < 0) (
    v_play_indices[lane] += 1;
    sp_grid = floor(0.001 + 1 * getGrid(lane, divs, v_play_indices[lane]) * sp_per_beat * getBeats());
    v_play_timers[lane] = sp_grid - sp_now;
  );

  // find next "grid line" such that timer will be >= sampleblock
  (v_play_timers[lane] < samplesblock) ? (
    isGridEnabled(lane, v_play_indices[lane]) && v_play_timers[lane] >= 0 ? (
      midisend(max(0, v_play_timers[lane]), $x90 + channel, getClickNote(lane), getClickVel(lane));
      v_play_off_timers[lane] = v_play_timers[lane] + 1;
    );
  );
  
  v_play_timers[lane] -= samplesblock;
  v_play_off_timers[lane] -= samplesblock;
  prev_beat_position = beat_position;
);

function decayHistogram(lane) local(i, decay_rate, round, prev_round, prev_pos)
(
  decay_rate = 0.95;
  
  round = floor(beat_position / getBeats());
  (v_rounds[lane] != round) || (beat_position < v_beat_pos[lane]) ? (
    i = 0;
    while (i<histogram_buckets) (
      v_histogram[histogram_size*lane + 2*i] *= decay_rate;
      i+=1;
    );
    v_histogram_max_value[lane] *= decay_rate;
    v_rounds[lane] = round;
    v_beat_pos[lane] = beat_position;
  );
);

function recordHistogram(reltime, lane)
(
  bucket = floor(reltime * histogram_buckets);
  // record as complex number x + 0i, i.e. x goes to event element
  v_histogram[histogram_size*lane + 2*bucket] += 1;
);

function recordHistory(reltime, hit, lane, note)
(
  v_history_time[hist_idx] = time_precise();
  v_history_rel_time[hist_idx] = reltime;
  v_history_hits[hist_idx] = hit;
  v_history_lane[hist_idx] = lane;
  v_history_notes[hist_idx] = note;
  events_count = events_count * hit_memory + 1;
  hits_count = hits_count * hit_memory + (hit==0);
  hit_rate = hits_count/events_count;
  (auto_shrink) ? (adjustErrorBound(hit_rate));
  hist_idx = (hist_idx + 1) % max_hist;
);

function recordTraining() local(t, prev_time)
(
  t = time();
  t != prev_time ? (
    graph_idx = (graph_idx+1) % max_graph;
    v_graph_hit_rate[graph_idx] = hit_rate;
    v_graph_error_bound[graph_idx] = error_bound;
    prev_time = t
  )
);

function recordMidiMonitor(lane)
(
  v_midi_monitor_last_hit[lane] = time_precise();
);

function listeningFor(lane, control)
(
  listen_note_control == controlId(lane, control);
);

function learnNote(note) local(i) 
(
  i = 0;
  while (listen_note_control && i < num_lanes)
  (
    listeningFor(i, control_button_click_note) ? 
      (setClickNote(i, note); listen_note_control = 0)
    : listeningFor(i, control_button_in_min_note) ? 
      (setInputMinNote(i, note); listen_note_control = 0)     
    : listeningFor(i, control_button_in_max_note) ? 
      (setInputMaxNote(i, note); listen_note_control = 0);     

    i += 1; 
  );
);

function learnController(controller) local(i) 
(
  i = 0;
  while (listen_note_control && i < num_lanes)
  (
    listeningFor(i, control_button_cc_controller) ? (setCCController(i, controller); listen_note_control = 0);
    i += 1; 
  );
);

function getLaneOfNote(note, channel, velocity) local(i, result, in_chan)
(
  result = -1;
  i = 0;
  while (i < num_lanes && (result == -1)) (
    in_chan = getInputChannel(i);
    ((in_chan == 0) || (in_chan == channel + 1)) &&
    (note >= getInputMinNote(i)) &&
    (note <= getInputMaxNote(i)) &&
    (velocity >= getInputMinVelocity(i)) &&
    (velocity <= getInputMaxVelocity(i)) ?
      result = i;
    i += 1;
  );
  result; 
);

function getLaneOfCC(controller, channel) local(i, result, cc_chan, cc_ctrl)
(
  result = -1;
  i = 0;
  while (i < num_lanes && (result == -1)) (
    cc_ctrl = getCCController(i);
    cc_ctrl != -1 ? (
      cc_chan = getCCChannel(i);
      ((cc_chan == 0) || (cc_chan == channel + 1)) && (cc_ctrl == controller) ? result = i;
    );
    i += 1;
  );
  result; 
);

isPlaying() ? (
  // TODO refactor into a loop bound by num_lanes.
  getClick(0) ? playGrid(0);
  getClick(1) && (num_lanes>1) ? playGrid(1);
  getClick(2) && (num_lanes>2) ? playGrid(2);
  getClick(3) && (num_lanes>3) ? playGrid(3);
  getClick(4) && (num_lanes>4) ? playGrid(4);
  getClick(5) && (num_lanes>5) ? playGrid(5);
  getClick(6) && (num_lanes>6) ? playGrid(6);
  getClick(7) && (num_lanes>7) ? playGrid(7);
);

while (midirecv(offset,msg1,msg2,msg3)) (
   noteStatus = msg1 & 0xF0;
   channel = msg1 & 0x0F;
   velocity = msg3;
   is_note_on = noteStatus==note_on && msg3!=0;
   is_cc = noteStatus==control_change;

   // TODO refactor below code like this:
   //   is_cc ? ( <cc logic> )
   //   : is_note_on ? ( <note on logic> )
   //   : ( < logic for other notes> )
   // Move the above variables like velocity to their correct branches.
   
   // Handle MIDI CC messages
   is_cc ? (
     controller = msg2;
     listen_note_control ? (
       learnController(controller);
     );

     cc_value = msg3;
     cc_lane = getLaneOfCC(controller, channel);
     cc_lane != -1 ? setCCValue(cc_lane, cc_value);
   );
   
   // Handle MIDI Note On messages
   is_note_on ? ( 
     note = msg2;
     lane = getLaneOfNote(note, channel, velocity);
     lane >= 0 ? recordMidiMonitor(lane);
   );
   isPlaying() && is_note_on ? (
     listen_note_control ? (
       learnNote(note);
       midisend(offset, msg1, msg2, msg3)
     )
     : lane < 0 ?
       midisend(offset, msg1, msg2, msg3)
     : (
       reltime = getRelTime(offset);
       hit = isHit(modOne(reltime + getRelLatencyCompensation()), lane);
       hit == 0 ? midisend(offset,msg1,note,msg3);
       decayHistogram(lane);
       recordHistory(reltime, hit, lane, note);
       recordHistogram(reltime, lane);
     )
   ) : (
     is_note_on && listen_note_control ? learnNote(note);
     midisend(offset,msg1,msg2,msg3); // passthrough other events
   );
);

isPlaying() ? recordTraining();

@gfx
#value_edit = "";

function isLButtonRelease()
(
  (1 ~ mouse_cap) & (1 & prev_mouse_cap);
);

function isRButtonPress()
(
  (2 & mouse_cap) & (2 ~ prev_mouse_cap);
);

function isRButtonRelease()
(
  (2 ~ mouse_cap) & (2 & prev_mouse_cap);
);

function isLButtonDoubleClick()
(
  isLButtonRelease() && (time_precise() - prev_mouse_l_button_release_time < 0.4); 
);

function rgb(r,g,b) 
(
  gfx_r = r;
  gfx_g = g;
  gfx_b = b;
);

function verticalDashedLine(x, y1, y2, dash, space) local(i, y)
(
  y = y1;
  dash = max(0, dash-1);
  loop ((y2-y1)/(dash + space),
    gfx_line(x,y, x, y+dash);
    y += dash+space);
);

function drawFrame(x,y,w,h)
(
  gfx_x = x;
  gfx_y = y;
  gfx_a = 1;
  rgb(0.5,0.5,0.5);
  gfx_lineto(x+w,y);
  rgb(1,1,1);
  gfx_lineto(x+w,y+h);
  gfx_lineto(x,y+h);
  rgb(0.5,0.5,0.5);
  gfx_lineto(x,y);
);

function printCenter(x,y,str) local(w,h)
(
  gfx_measurestr(str,w,h);
  gfx_x = x-w/2;
  gfx_y = y-h/2;
  gfx_printf(str);
);

function printValueEdit(x,y) local(w,h, margin)
(
  (strlen(#value_edit) > 0) ? 
  (
    rgb(0,0,0);
    gfx_setfont(1, "Arial", 24);
    gfx_measurestr(#value_edit,w,h);
    gfx_a=0.6;
    margin=4;
    gfx_rect(x-w/2-margin, y-h/2-margin, w+margin*2, h+margin*2);
    gfx_a=1;
    gfx_x = x-w/2;
    gfx_y = y-h/2;
    rgb(1,1,1);
    gfx_printf(#value_edit);
    #value_edit = "";
  );
);

function printBottomLeft(x,y,str) local(w,h)
(
  gfx_measurestr(str,w,h);
  gfx_x = x-w;
  gfx_y = y-h;
  gfx_printf(str);
);

function printBottomRight(x,y,str) local(w,h)
(
  gfx_measurestr(str,w,h);
  gfx_x = x;
  gfx_y = y-h;
  gfx_printf(str);
);

function noteName(note) local(names,sharps,nm,sh,str)
(
  names  = "CCDDEFFGGAAB";
  sharps = $x54A;
  nm = str_getchar(names, note%12);
  sh = ((1 << (note%12)) & sharps ? "#" : "");
  sprintf(str,"%c%s\%d", nm, sh, floor(note/12));
  str;
);


fresh_event_thresh = 2;
function drawEvent(x, y, note, age) local(str)
(
  gfx_circle(x, y, 4, 1, 0);
  
  (age < fresh_event_thresh) ? (
    gfx_a = ((fresh_event_thresh-age)/fresh_event_thresh);
    gfx_circle(x, y, 7, 0, 0);
  )
);

function isMouseInRect(l,t,w,h)
(
  mouse_x >= l && mouse_x <= l+w && mouse_y >= t && mouse_y <= t+h;
);

function dragPhase(lane,focus_control,divs, l,t,w,h) local(dx, ph, orig_value, orig_x, prev_x, resolution, ctrl_id)
(
  ctrl_id = controlId(lane, control_phase);
  
  (mouse_x != prev_x) && (active_control == ctrl_id) ? (
      dx = orig_value + (mouse_x - orig_x)*divs/w/2;
      resolution = mouse_cap & 4 ? 12 : 360;  
      dx = floor(dx*resolution + 0.5) / resolution;
      setPhase(lane, dx);
      prev_x = mouse_x;
    ) 
  : active_control == 0 && focus_control == ctrl_id && (mouse_cap & 1) ? (
      active_control = focus_control;
      orig_value = getPhase(lane);
      orig_x = mouse_x;
  );
  
  focus_control == ctrl_id && isLButtonDoubleClick() ? setPhase(lane, 0);
  
  (active_control == ctrl_id || focus_control == ctrl_id) ? (
    ph = getPhase(lane);
    sprintf(#value_edit, "Phase: %0.2f (%0.0f\xB0), left-drag to change, right-click to toggle grid", ph, ph*360);
  );  
);

function dragSwing(lane,focus_control,divs, l,t,w,h) local(dx, sw, orig_value, orig_x, prev_x, resolution, ctrl_id)
(
  ctrl_id = controlId(lane, control_swing);
  
  (mouse_x != prev_x) && (active_control == ctrl_id) ? (
      dx = orig_value + (mouse_x - orig_x)*divs/w/2;
      resolution = mouse_cap & 4 ? 12 : 360;  
      dx = floor(dx*resolution + 0.5) / resolution;
      setSwing(lane, dx);
      prev_x = mouse_x;
    ) 
  : active_control == 0 && focus_control == ctrl_id && (mouse_cap & 1) ? (
      active_control = focus_control;
      orig_value = getSwing(lane);
      orig_x = mouse_x;
  );
  
  focus_control == ctrl_id && isLButtonDoubleClick() ? setSwing(lane, 0);

  (active_control == ctrl_id || focus_control == ctrl_id) ? (
    sw = getSwing(lane);
    sprintf(#value_edit, "Swing: %0.2f (%0.0f\xB0), left-drag to change, right-click to toggle grid", sw, sw*360);  );
);

function emptyRect(l,t,w,h)
(
  gfx_x = l;
  gfx_y = t;
  gfx_lineto(l+w-1,t);
  gfx_lineto(l+w-1,t+h-1);
  gfx_lineto(l,t+h-1);
  gfx_lineto(l,t);
);

function drawText(w,h,str) local(strw, strh)
(
  rgb(0.7, 0.7, 0.7);
  l = gfx_x;
  t = gfx_y;
  gfx_a = 1;
  gfx_measurestr(str, strw, strh);
  w=max(w,strw+8);
  printCenter(l+w/2, t+h/2, str);
  gfx_x = l + w;
  gfx_y = t;
);

// Returns 1 if in focus.
function drawButton(lane, id, w, h, str, state) local(strw, strh, focus, button_id, focus_brightness, state_brightness, press_brighness, delta)
(
  l = gfx_x;
  t = gfx_y;
  gfx_measurestr(str, strw, strh);
  w=max(w,strw+8);
  button_id = controlId(lane, id);
  !active_control && isMouseInRect(l,t,w,h) && mouse_cap & 1 ? active_control = button_id;
  focus = (!active_control || active_control == button_id) && isMouseInRect(l,t,w,h);
  focus_brightness = 0.1 * focus;
  state_brightness = 0.1 * state;
  press_brightness = 0.2 * focus * (mouse_cap & 1);
  delta = focus_brightness - press_brightness;
  rgb(0.2 + delta, 0.2 + delta+state_brightness, 0.2 + delta+state_brightness);
  gfx_rect(l+1,t+1,w-2,h-2);
  gfx_a = 1;  
  rgb(0.7+delta, 0.7+delta, 0.7+delta);
  printCenter(l+w/2, t+h/2, str);
  gfx_x = l+w;
  gfx_y = t;
  focus;
);

// Draw a disabled button (grayed out, no interaction) if disabled is 1, otherwise a "stateless" button.
function drawDisableableButton(lane, id, w, h, str, disabled) local(strw, strh, l, t)
(
  !disabled ? drawButton(lane, id, w, h, str, 0) 
  : (l = gfx_x;
     t = gfx_y;
     gfx_measurestr(str, strw, strh);
     w=max(w,strw+8);
     rgb(0.15, 0.15, 0.15);
     gfx_rect(l+1,t+1,w-2,h-2);
     gfx_a = 1;  
     rgb(0.4, 0.4, 0.4); // Gray text
     printCenter(l+w/2, t+h/2, str);
     gfx_x = l+w;
     gfx_y = t;
     // no focus
     0;);
);

function toggleListen(control)
(
  listen_note_control = listen_note_control == control ? 0 : control;
);

function noteButtonToolTip(control, tip, focus, note)
(
  (listen_note_control == control) ? sprintf(#value_edit, "%s: LISTENING", tip)
  : focus                          ? sprintf(#value_edit, "%s: %s (%d)", tip, noteName(note), note); 
);

// chan is 0-16, where 0 represents all channels.
function inputChannelButtonToolTip(chan, tip, focus)
(
    focus ? (
      chan ? sprintf(#value_edit, "%s: %d", tip, chan)
           : sprintf(#value_edit, "%s: ALL", tip);
    )
);

function drawToolBar(lane, l, t, w, h)
local(left_button_release, right_button_release, focus_expand_toolbar, focus_div_up, focus_div_down, focus_div, focus_click_vel_up, focus_click_vel_down, focus_click_vel,
      focus_toggle_click, focus_click_note, focus_in_channel_up, focus_in_channel_down, focus_in_channel, focus_in_max_note, focus_in_min_note,
      focus_click_channel_down, focus_click_channel_up, focus_click_channel, focus_move_lane_up, focus_move_lane_down, focus_delete_lane
      button_width, click_note, can_move_lane_up, can_move_lane_down, can_delete_lane, focus_cc_channel_up, focus_cc_channel_down,
      min_note, max_note, control_button_click_note_id, control_button_in_max_note_id, control_button_in_min_note_id,
      cc_controller, focus_cc_controller, control_button_cc_controller_id, cc_controller_label)
(
  gfx_setfont(1, "Arial", 14);
  left_button_release = isLButtonRelease();
  right_button_release = isRButtonRelease();
  mouse_wheel_dir = mouse_wheel / 120;
  expand_toolbar ? (
    rgb(0,0,0);
    gfx_a = 0.6;
    gfx_rect(l-1,t-1,w+2,h+2);
    gfx_a = 1;
  ) : gfx_a = 0.6;
  gfx_x = l+1;
  gfx_y = t;
  focus_expand_toolbar = drawButton(lane, control_button_expand, h, h, expand_toolbar ? "<<" : ">>", 0);
  left_button_release && focus_expand_toolbar ? expand_toolbar = !expand_toolbar;
  focus_expand_toolbar ? sprintf(#value_edit, "Toggle toolbar");
  
  expand_toolbar ? (
    click_note    = getClickNote(lane);
    min_note      = getInputMinNote(lane);
    max_note      = getInputMaxNote(lane);
    cc_controller = getCCController(lane);
    control_button_click_note_id    = controlId(lane, control_button_click_note);
    control_button_in_max_note_id   = controlId(lane, control_button_in_max_note);
    control_button_in_min_note_id   = controlId(lane, control_button_in_min_note);
    control_button_cc_controller_id = controlId(lane, control_button_cc_controller);

    can_move_lane_up   = activeLane(lane-1);
    can_move_lane_down = activeLane(lane+1);
    can_delete_lane    = num_lanes > 1;

    button_width = h;

    focus_move_lane_up   = drawDisableableButton(lane, control_button_move_lane_up,   button_width, h, "↑", !can_move_lane_up);
    focus_move_lane_down = drawDisableableButton(lane, control_button_move_lane_down, button_width, h, "↓", !can_move_lane_down);
    focus_delete_lane    = drawDisableableButton(lane, control_button_delete_lane,    button_width, h, "x", !can_delete_lane);
    
    // Draw divisions buttons
    drawText(0, h, "Divisions:");
    focus_div_down = drawButton(lane, control_button_div_down, button_width, h, "-", 0);
    focus_div_up   = drawButton(lane, control_button_div_up,   button_width, h, "+", 0);
    focus_div      = focus_div_down || focus_div_up;
    
    // Draw click buttons
    drawText(0, h, "Click:");
    focus_toggle_click       = drawButton(lane, control_button_click,              button_width*2,   h, getClick(lane)? "ON" : "OFF", getClick(lane));
    focus_click_note         = drawButton(lane, control_button_click_note,         button_width*1.5, h, noteName(click_note),         listen_note_control == control_button_click_note_id);

    focus_click_vel_down     = drawButton(lane, control_button_click_vel_down,     button_width,     h, "V-",                         0);
    focus_click_vel_up       = drawButton(lane, control_button_click_vel_up,       button_width,     h, "V+",                         0);
    focus_click_vel          = focus_click_vel_down || focus_click_vel_up;

    focus_click_channel_down = drawButton(lane, control_button_click_channel_down, button_width,     h, "CH-",                        0);
    focus_click_channel_up   = drawButton(lane, control_button_click_channel_up,   button_width,     h, "CH+",                        0);
    focus_click_channel      = focus_click_channel_down || focus_click_channel_up;
    
    // Draw input filter buttons
    drawText(0, h, "Input Filter:");    
    focus_in_min_note = drawButton(lane, control_button_in_min_note, button_width*1.5, h, noteName(min_note), listen_note_control == control_button_in_min_note_id);
    drawText(0, h, "->");
    focus_in_max_note = drawButton(lane, control_button_in_max_note, button_width*1.5, h, noteName(max_note), listen_note_control == control_button_in_max_note_id);                 

    focus_in_channel_down = drawButton(lane, control_button_in_channel_down, button_width, h, "CH-", 0);
    focus_in_channel_up   = drawButton(lane, control_button_in_channel_up,   button_width, h, "CH+", 0);
    focus_in_channel      = focus_in_channel_down || focus_in_channel_up;

    // Draw MIDI CC filter buttons
    focus_cc_channel_down = drawButton(lane, control_button_cc_channel_down, button_width, h, "CC CH-", 0);
    focus_cc_channel_up   = drawButton(lane, control_button_cc_channel_up,   button_width, h, "CC CH+", 0);
    focus_cc_channel      = focus_cc_channel_down || focus_cc_channel_up;

    cc_controller != -1 ? sprintf(cc_controller_label, "%d", cc_controller)
                        : sprintf(cc_controller_label, "no CC");
    focus_cc_controller = drawButton(lane, control_button_cc_controller, button_width*1.5, h, cc_controller_label, listen_note_control == control_button_cc_controller_id);

    // Perform left-click side effects on buttons
    left_button_release ? (
      focus_cc_channel_down      ? setCCChannel(lane, getCCChannel(lane)-1)
      : focus_cc_channel_up      ? setCCChannel(lane, getCCChannel(lane)+1)
      : focus_cc_controller      ? toggleListen(control_button_cc_controller_id)
      : focus_click_channel_down ? setClickChannel(lane, getClickChannel(lane)-1)
      : focus_click_channel_up   ? setClickChannel(lane, getClickChannel(lane)+1)
      : focus_click_note         ? toggleListen(control_button_click_note_id)
      : focus_click_vel_down     ? setClickVel(lane, floor(getClickVel(lane)/4)*4-4)
      : focus_click_vel_up       ? setClickVel(lane, floor(getClickVel(lane)/4)*4+4)
      : focus_delete_lane        ? deleteLane(lane)
      : focus_div_down           ? setDivs(lane, getDivs(lane)-1)
      : focus_div_up             ? setDivs(lane, getDivs(lane)+1)
      : focus_in_channel_down    ? setInputChannel(lane, getInputChannel(lane)-1)
      : focus_in_channel_up      ? setInputChannel(lane, getInputChannel(lane)+1)
      : focus_in_max_note        ? toggleListen(control_button_in_max_note_id)
      : focus_in_min_note        ? toggleListen(control_button_in_min_note_id)
      : focus_move_lane_down     ? moveLane(lane, lane+1)
      : focus_move_lane_up       ? moveLane(lane, lane-1)
      : focus_toggle_click       ? setClick(lane, !getClick(lane))
    );
    
    // Perform right-click side effects on buttons
    right_button_release ? (
      focus_toggle_click ? toggleClickAllLanes()
    );

    // Perform mouse-wheel side effects on buttons
    mouse_wheel_dir ? (
      focus_cc_channel      ? setCCChannel(lane, getCCChannel(lane)+mouse_wheel_dir)
      : focus_click_channel ? setClickChannel(lane, getClickChannel(lane)+mouse_wheel_dir)
      : focus_click_note    ? setClickNote(lane, click_note+mouse_wheel_dir)
      : focus_click_vel     ? setClickVel(lane, getClickVel(lane)+mouse_wheel_dir)
      : focus_div           ? setDivs(lane, getDivs(lane)+mouse_wheel_dir)
      : focus_in_channel    ? setInputChannel(lane, getInputChannel(lane)+mouse_wheel_dir)
      : focus_in_max_note   ? setInputMaxNote(lane, max_note+mouse_wheel_dir)
      : focus_in_min_note   ? setInputMinNote(lane, min_note+mouse_wheel_dir)
      : focus_toggle_click  ? setClick(lane, mouse_wheel_dir);

      // Disable mouse-wheel for note-listening buttons when learning
      !listen_note_control ? (
        focus_click_note      ? setClickNote(lane, click_note+mouse_wheel_dir)
        : focus_in_max_note   ? setInputMaxNote(lane, max_note+mouse_wheel_dir)
        : focus_in_min_note   ? setInputMinNote(lane, min_note+mouse_wheel_dir)
        : focus_cc_controller ? setCCController(lane, cc_controller+mouse_wheel_dir);
      );
    );
    
    // Static tooltips
    focus_click_vel        ? sprintf(#value_edit, "Click Velocity: %d", getClickVel(lane))
    : focus_delete_lane    ? sprintf(#value_edit, "Delete lane")
    : focus_div            ? sprintf(#value_edit, "Divisions: %d", getDivs(lane))
    : focus_move_lane_down ? sprintf(#value_edit, "Move lane down")
    : focus_move_lane_up   ? sprintf(#value_edit, "Move lane up")
    : focus_toggle_click   ? sprintf(#value_edit, "Click: %s (%s)", getClick(lane) ? "On" : "Off", "Right click to toggle all")
    : focus_click_channel  ? sprintf(#value_edit, "Click Channel: %d", getClickChannel(lane));

    // Input channel tooltips
    inputChannelButtonToolTip(getInputChannel(lane), "Input Channel",    focus_in_channel);
    inputChannelButtonToolTip(getCCChannel(lane),    "Input CC Channel", focus_cc_channel);
    
    // Note-listening tooltips
    noteButtonToolTip(control_button_click_note_id,  "Click Note",     focus_click_note,  click_note);
    noteButtonToolTip(control_button_in_max_note_id, "Input Max Note", focus_in_max_note, max_note);
    noteButtonToolTip(control_button_in_min_note_id, "Input Min Note", focus_in_min_note, min_note);

    // MIDI CC-listening tooltips
    (listen_note_control == control_button_cc_controller_id) ? sprintf(#value_edit, "Input CC Controller: LISTENING")
    : focus_cc_controller                                    ? (
      cc_controller != -1 ? sprintf(#value_edit, "Input CC Controller: %d", cc_controller)
                          : sprintf(#value_edit, "Input CC Controller: NONE");
    );
  )
);

function drawMidiMonitor(lane, l,t,w,h) local(age)
(
  age = getMidiMonitorAge(lane);
  gfx_a = 1-min(age,1);
  rgb(1,1,0);
  gfx_rect(l,t,w,h);
  gfx_a = 0.2;
  emptyRect(l,t,w-1,h-1);
);

function drawHistogram(lane, l, t, w, h, from, to, start_alpha, end_alpha) local (value, x, y, normalized)
(
  rgb(0.5, 0.5, 0.5);
  
  memcpy(v_histogram_tmp, v_histogram + lane*histogram_size, histogram_size);
  i = 0;
  while(i < histogram_buckets) (
    v_histogram_tmp[i*2] /= histogram_buckets;
    i+=1;
  );
  fft(v_histogram_tmp, histogram_buckets);
  convolve_c(v_histogram_tmp, v_normal_mask, histogram_buckets);
  ifft(v_histogram_tmp, histogram_buckets);
  i = from;
  max_value = 0;
  prev_max_value = v_histogram_max_value[lane];
  while(i < to) (
    x = l+i;
    value = v_histogram_tmp[2*floor(modOne(-getRelLatencyCompensation() + i/w)*histogram_buckets)];
    max_value = max(value, max_value);
    normalized = value / (prev_max_value ? prev_max_value : 1); 
    y = max(t, t+h*(1-normalized/2));
    
    gfx_a = (start_alpha + (end_alpha - start_alpha) * (i - from) / (to - from));
    gfx_line(x,y,x,t+h);
    i+=1;
  );
  max_value;
);

function drawGradientMargins(l, t, w, h, w_margin) local(grad_alpha, black_margin)
(
  rgb(0, 0, 0);
  black_margin = ceil(0.3 * w_margin);
  grad_alpha = 1 / (w_margin - black_margin);
  gfx_rect(l, t, black_margin, h);
  gfx_gradrect(l + black_margin, t, w_margin - black_margin, h, 0, 0, 0, 1, 0, 0, 0, -grad_alpha, 0, 0, 0, 0);
  gfx_rect(l + w - black_margin, t, black_margin, h);
  gfx_gradrect(l + w - w_margin+1, t, w_margin - black_margin, h, 0, 0, 0, 0, 0, 0, 0, grad_alpha, 0, 0, 0, 0);
);

function drawGrid(lane, l,t,w,h) local(beat_mark_ratio, i, x,y, age, birth, hit,now,low,grid,high,i,divs, toolbar_height, focus_control,beats)
(  
  focus_control = 0;
  toolbar_height = 20;
 
  rgb(0.2, 0.2, 0.2);
  gfx_a = 1;
  
  gfx_rect(l, t, w, h);
  
  // Draw gradient margins for wrapping the pattern
  pattern_wrap = 0.15;
  w_pattern = w / (1+pattern_wrap);
  w_margin = (w-w_pattern)/2;
  l_pattern = l + w_margin;

  drawGradientMargins(l, t, w, h, w_margin);
  
  // Draw "grid" area
  divs = getDivs(lane);
    
  // Draw green areas
  rgb(0, 0.4, 0);
  i=0;
  loop(divs+1,
    isGridEnabled(lane, i) ? (
      low = l_pattern+getEarly(lane, divs, i)*w_pattern;
      high = l_pattern+getLate(lane, divs, i)*w_pattern+1;
      gfx_rect(low, t, high-low, h);
    );
    i+=1;
  );
  
  histo_alpha = 0.62;
  drawHistogram(lane, l_pattern - w_pattern, t, w_pattern, h, w_pattern - w_margin, w_pattern, 0, histo_alpha);
  drawHistogram(lane, l_pattern + w_pattern, t, w_pattern, h, 0, w_margin, histo_alpha, 0);
  max_value = drawHistogram(lane, l_pattern, t, w_pattern, h, 0, w_pattern, histo_alpha, histo_alpha);
  fit_speed = 0.05;
  v_histogram_max_value[lane] = (1-fit_speed)*prev_max_value + fit_speed*max_value;
  
  // Draw dashed rhythm lines
  gfx_a = 0.6;
  i=0;
  ctrl_phase_id = controlId(lane, control_phase);
  ctrl_swing_id = controlId(lane, control_swing);
  loop(divs+1, 
    grid = l_pattern+getGrid(lane, divs, i)*w_pattern;
    grid_mask_mode ? (
      mouse_focus = isMouseInRect(grid - w_pattern/divs/2, t, w_pattern/divs, h - toolbar_height);
      mouse_focus && (mouse_cap & 2) ? setGridMask(lane, i, 2-grid_mask_mode);
    )
    : (
      mouse_focus = isMouseInRect(grid-8, t, 16, h - toolbar_height);
      mouse_focus && isRButtonPress() ? grid_mask_mode = 1 + getGridMask(lane, i);
      ((i+1)%2) && ((!active_control && mouse_focus) || (active_control == ctrl_phase_id)) ? (
        focus_control = ctrl_phase_id;
        rgb(0,0.7,0.7);
        gfx_rect(grid-6, t, 12, h);
      );
      (i%2) && ((!active_control && mouse_focus) || (active_control == ctrl_swing_id)) ? (
        focus_control = ctrl_swing_id;
        rgb(0.5,0,1);
        gfx_rect(grid-6, t, 12, h);
      );
    );
    rgb(0.67, 0.67, 0.67);
    verticalDashedLine(grid, t, t+h, 1, 5);
    isGridEnabled(lane, i) ? 
      (sprintf(str, "%d", (i%divs)+1); rgb(1,1,1)) 
    : (sprintf(str, "(%d)", (i%divs)+1); rgb(0.5, 0.5, 0.5));
    gfx_setfont(1, "Arial", 16);
    printCenter(grid,t+h/2,str);
    i+=1;
  );
  
  isRButtonRelease() ? grid_mask_mode = 0;
    
  // Draw beat marks
  
  (lane == 0) ? gfx_setfont(1, "Arial", 12);
  i=0;
  beat_mark_ratio = 0.20;
  gfx_a = 1;
  beats = getBeats();
  loop(beats+1,
    grid = l_pattern + i*w_pattern/beats;
    
    ((lane == 0) && (i < beats)) ? (
      gfx_x = grid + 3;
      gfx_y = t + 1;
      (i < beats) ? (
        gfx_a = 0.4;
        (i % 2 == 0) ? rgb(0, 0, 0) : rgb(0.5, 0.5, 0.5);
        gfx_rect(grid,t, w_pattern/beats, 14);
      );
      rgb(1,1,1);
      gfx_a = 1;
      gfx_printf("%d",(i % beats)+1);
    );
    
    rgb(1, 1, 1);
    gfx_line(grid,t, grid,t+h*beat_mark_ratio);
    gfx_line(grid,t+h*(1-beat_mark_ratio), grid,t+h);
    
    i+=1;
  );
  gfx_setfont(1, "Arial", 14);
  
  isPlaying() ? (
    i=0;
    now = time_precise();
    // Draw history (events)
    loop(max_hist,
      birth = v_history_time[i];
      (birth != 0) && (v_history_lane[i] == lane) ? (
        hit = v_history_hits[i];
        age = min(max_age, now - birth);
        (hit == 0) ? rgb(0,1,0) : 
          (hit == 1) ? rgb(1,0,0) : rgb(0,0,1);
        x = w_pattern * modOne(v_history_rel_time[i] + getRelLatencyCompensation());
        y = age*20;
        gfx_a = 1 - sqrt(y/h);
        y < h ? (
          drawEvent(l_pattern+x,t+y, v_history_notes[i], age);
          rgb(0.5, 0.5, 0.5);
          (x < w_margin) ?
            drawEvent(l_pattern+w_pattern+x,t+y, v_history_notes[i], age);
          (x >= w_pattern - w_margin) ?
            drawEvent(l_pattern-w_pattern+x,t+y, v_history_notes[i], age);
        );
        age == max_age ? (v_history_time[i] = 0);
      );
      i += 1;
    );
    
    // Draw vertical time line and highlight current beat
    curr_beat = beat_position % beats;
    rgb(1,1,0);
    x = l_pattern + w_pattern * getRelTime(0);
    gfx_a = 0.15;
    current_rel_beat = (curr_beat + 1) / beats;
    delta_x = ceil(l_pattern+w_pattern*current_rel_beat)-x;
    gfx_rect(x, t, delta_x, h);
    gfx_a = 1;
    gfx_line(x, t, x, t+h);
    gfx_a = 1-(x - l_pattern) / w_margin;
    gfx_line(x+w_pattern, t, x+w_pattern, t+h);
    gfx_a = 1-(l_pattern + w_pattern - x) / w_margin;
    gfx_line(x-w_pattern, t, x-w_pattern, t+h);
  );  
  
  drawToolBar(lane, l+2,t+h-toolbar_height-1,w-2,20);
  drawMidiMonitor(lane, l+w-12, t+h-14, 8, 8);  
    
  dragPhase(lane,focus_control,divs, l, t, w, h);
  dragSwing(lane,focus_control,divs, l, t, w, h);
  
  printValueEdit(l+w/2, t+h/2);
 
  drawFrame(l-1, t-1, w+2, h+2);
);

function clearTrainingGraph()
(
  memset(v_graph_error_bound, 0, max_graph);
  memset(v_graph_hit_rate, 0, max_graph);
  memset(v_histogram, 0, 4*histogram_size);
  memset(v_histogram_max_value, 1, 4);
  graph_idx = 0;
  hit_rate = 0;
);

function drawTrainingGraphTitle(left, top) local(error_bound_percent)
(
  gfx_a = 1;
  gfx_x = left;
  gfx_y = top;
  gfx_setfont(1, "Arial", 15);
  rgb(1,1,1);
  gfx_printf("10 Minute Training Graph (");
  rgb(1,1,0);
  gfx_printf("Hit Rate: %0.0f%%", hit_rate*100);
  rgb(1,1,1);
  gfx_printf(", ");
  rgb(0,1,1);
  
  error_bound_percent = getErrorRange()*100 * 2*max_divs;
  gfx_printf("Error Bound: \xB1%dms (%d%%)", error_bound*error_bound_scale, error_bound_percent);
  rgb(1,1,1);
  gfx_printf(")");
  
  gfx_x += 20;
  drawButton(0, control_button_training_clear, 0, 16, "Clear", 0) ?
    (isLButtonRelease() ? clearTrainingGraph();)
);

function drawTrainingGraph(graph_left, graph_top, graph_width, graph_height) local(i, graph_x_ratio, pr)
( 
  gfx_a = 1;
  rgb(0.27, 0.27, 0.4); // greyish purple
  gfx_rect(graph_left, graph_top, graph_width, graph_height);

  gfx_setfont(1, "Arial", 12);
  graph_x_ratio = graph_width/(max_graph-1);
  i=0;
  rgb(0.67, 0.67, 0.67); 
  loop(max_graph/10,
    (i%60 == 0) ?
      (gfx_line(graph_left + i*graph_x_ratio, graph_top, graph_left + i*graph_x_ratio, graph_top+graph_height);
      sprintf(str, "%2d:00", 1+i/60);
      printBottomLeft(graph_left + (i+60)*graph_x_ratio-1, graph_top + graph_height, str))
    : verticalDashedLine(graph_left + i*graph_x_ratio, graph_top, graph_top+graph_height, 4, 5);
    i += 10);
  gfx_line(graph_left + width, graph_top, graph_left + width, graph_top + graph_height);

  // Draw verical time line
  rgb(1, 1, 1);
  gfx_line(graph_left + graph_idx*graph_x_ratio, graph_top, graph_left + graph_idx*graph_x_ratio, graph_top + graph_height);

  // hit rate
  i=0;
  rgb(1,1,0);
  gfx_x = graph_left;
  gfx_y = graph_top + graph_height*(1 - v_graph_hit_rate[0]);
  loop(max_graph,
    hr = max(0, min(1, 1 - v_graph_hit_rate[i]));
    gfx_lineto(graph_left + i*graph_x_ratio, graph_top + graph_height*hr);
    i+=1);

  // error_bound
  i=0;
  rgb(0,1,1);
  gfx_x = graph_left;
  gfx_y = graph_top + graph_height*(1 - v_graph_error_bound[0]);
  loop(max_graph,
    pr = max(0, min(1, 1 - v_graph_error_bound[i]));
    gfx_lineto(xmargin + i*graph_x_ratio, graph_top + graph_height*pr);
    i+=1);

  drawFrame(xmargin-1, graph_top-1, width+2, graph_height+2);
);

function drawLanes(y) local(lane)
(
  lane=1;
  while(lane<num_lanes)
  (
    drawGrid(lane, xmargin, y, width, grid_height-grid_margin);
    y+=grid_height;
    lane+=1;
  );
  y;
);

xmargin = 4;
header_margin = 20;
footer_margin = 4;

gfx_x = xmargin;
gfx_y = 1;
rgb(1,1,1);
gfx_setfont(1, "Arial", 15);
gfx_printf("Rhythm Grid:");

drawButton(0, control_button_halve_pattern, 0, 16, "/2 pattern", 0) ?
  (sprintf(#value_edit, "Truncate pattern to the first half using half as many beats");
   isLButtonRelease() ? halveDuration(););
drawButton(0, control_button_double_pattern, 0, 16, "x2 pattern", 0) ?
  (sprintf(#value_edit, "Duplicate the current pattern using twice as many beats");
   isLButtonRelease() ? doubleDuration(););

width = gfx_w-xmargin*2;
total_grid_height = max(200, (gfx_h - header_margin - footer_margin) * 0.7);
total_grid_height -= total_grid_height % num_lanes;

grid_margin = 6;
grid_height = total_grid_height / num_lanes;
drawGrid(0, xmargin, header_margin, width, grid_height-grid_margin);
y = drawLanes(header_margin + grid_height);

drawTrainingGraphTitle(xmargin, y);
y+=20;
drawTrainingGraph(xmargin, y, width, max(80, gfx_h - footer_margin - y));

isLButtonRelease() ? prev_mouse_l_button_release_time = time_precise();
prev_mouse_cap = mouse_cap;
mouse_wheel = 0;
mouse_cap & 1 == 0 ? active_control = 0;

@serialize
// This causes the general state to be kept between DAW "play"s
file_var(0, dummy);
